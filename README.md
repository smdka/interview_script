# Скрипт для проведения тех. собеса (junior+/middle Java dev)

Скрипт для проведения тех собеса содержит в себе три части:

1. [Smalltalk](#smalltalk)
2. [Теория](#теория)
3. [Лайф-кодинг](#лайф-кодинг)

## Smalltalk

Добрый день! Меня зовут Илья.

С нами сегодня (ФИО и должность коллеги).

Наша встреча займет около часа.

В рамках встречи мы с тобой познакомимся. Ты расскажешь немного о себе, а мы о компании.

Расскажи немного о себе, но не углубляясь в профессиональный опыт. К опыту перейдем позднее.

    Кандидат рассказывает о себе

Давай поподробнее остановимся на твоем последнем месте работы.
Расскажи чем занималась компания, сколько человек было в команде, с кем ты коммуницировал, как выглядела иерархия, кто
принимал решения, как выстраивались коммуникации внутри команды, был ли наставник, какие были достижения, чем гордится и
факапы, как вышел из него.

    Дальше переходим непосредственно к технической части.

## Теория

### 1. ООП

#### 1.1 Что такое паттерны (шаблоны проектирования)? С какими ты сам сталкивался и в каких ситуациях?

Ожидаемый ответ:
Паттерны ООП (Object-Oriented Programming) - это повторяемые решения, которые позволяют разработчикам проектировать и
разрабатывать более эффективные, гибкие и поддерживаемые программные системы.

Паттерны ООП представляют собой описания проблем и их решений в контексте объектно-ориентированного программирования.
Они помогают разработчикам избежать повторения ошибок и создавать более качественные программные системы.

### 2. Java Core

#### 2.1 Каковы различия между примитивными и ссылочными типами данных в Java?

Ожидаемый ответ:
В Java существуют два основных типа данных: примитивные типы и ссылочные типы.

Примитивные типы - это типы данных, встроенные в язык Java, которые используются для хранения простых значений, таких
как целые числа, числа с плавающей точкой, логические значения и символы. Эти типы хранятся непосредственно в памяти и
имеют фиксированный размер. Примеры примитивных типов - int, double, boolean и char.

Ссылочные типы, с другой стороны, представляют собой объекты, создаваемые во время выполнения и хранящиеся в памяти как
указатели. Эти типы используются для представления более сложных структур данных, таких как массивы, строки и
пользовательские классы. Примеры ссылочных типов - String, Integer и пользовательские классы, определяемые
программистом.

Основное различие между примитивными и ссылочными типами заключается в том, как они хранятся в памяти. Примитивные типы
хранят фактическое значение непосредственно, тогда как ссылочные типы хранят ссылку на объект в памяти. Это означает,
что когда вы присваиваете ссылочный тип переменной, вы фактически храните копию ссылки, а не самого объекта.

#### 2.1.1 Если поля объекта являются примитивными типами, то где они хранятся? В куче или в стеке?

Ожидаемый ответ:
Все, что связано с объектом хранится в куче.

#### 2.2 Опишите внутреннюю структуру HashMap в Java. Как она использует хэш-функцию для определения индекса массива, где хранится значение? Как она решает проблему коллизий, когда два ключа имеют одинаковый хэш-код?

Ожидаемый ответ:
Внутренняя структура HashMap состоит из массива записей, где каждая запись представляет собой пару ключ-значение.
Хэш-функция используется для определения индекса массива, где хранится значение. Когда ключ добавляется в карту, его
хэш-код вычисляется и используется для определения индекса массива. Если в этом индексе уже есть значение, то происходит
коллизия. В этом случае HashMap использует связанный список для хранения значений с одинаковым хэш-кодом. Каждая запись
в связанном списке содержит ключ, значение и ссылку на следующую запись в списке.

#### 2.3 Как работает TreeSet в Java? Как она хранит и извлекает значения, и как поддерживает порядок элементов?

Ожидаемый ответ:

TreeSet использует красно-черное дерево для хранения элементов. Красно-черное дерево - это самобалансирующееся двоичное
дерево поиска, которое поддерживает порядок элементов. Когда элемент добавляется в TreeSet, он вставляется в дерево в
соответствии с его значением. Если элемент уже существует в дереве, то он не добавляется. При извлечении элемента по
значению, TreeSet использует дерево для поиска элемента. Если элемент найден, то он возвращается. Если нет, то
возвращается null. Порядок элементов в TreeSet поддерживается за счет балансировки дерева после добавления или удаления
элементов.

#### 2.4 Исключения. Какие исключения существуют и чем отличаются?

Ожидаемый ответ:

В Java, исключения делятся на два основных типа: проверяемые (checked) и непроверяемые (unchecked).

Проверяемые исключения (Checked Exceptions)

Проверяемые исключения наследуются от класса Exception (кроме RuntimeException). Они проверяются компилятором на этапе
компиляции, поэтому если метод может вызвать проверяемое исключение, он должен либо обработать его с помощью блока
try-catch, либо объявить его в сигнатуре метода с помощью ключевого слова throws.

Примеры проверяемых исключений:

    IOException
    SQLException
    FileNotFoundException

Непроверяемые исключения (Unchecked Exceptions)

Непроверяемые исключения наследуются от класса RuntimeException или Error. Они не проверяются компилятором на этапе
компиляции, поэтому если метод может вызвать непроверяемое исключение, он не обязан обработать его или объявить его в
сигнатуре метода.

Примеры непроверяемых исключений:

    NullPointerException
    ArrayIndexOutOfBoundsException
    ClassCastException

Ошибки (Errors)

Ошибки наследуются от класса Error. Они представляют собой серьезные ошибки, которые не могут быть обработаны
программой, например, ошибки виртуальной машины или ошибки при загрузке классов.

Примеры ошибок:

    OutOfMemoryError
    StackOverflowError
    LinkageError

В общем, проверяемые исключения используются для обработки исключительных ситуаций, которые могут возникнуть во время
выполнения программы, но которые могут быть обработаны программой. Непроверяемые исключения используются для обработки
исключительных ситуаций, которые не могут быть обработаны программой, а ошибки используются для обработки серьезных
ошибок, которые не могут быть обработаны программой.

#### 2.5 Что такое Stream API? Какие виды операций бывают? Чем map отличается от flatMap?

Ожидаемый ответ:

Stream API поддерживает две основные категории операций: промежуточные (intermediate) и конечные (terminal).

Промежуточные операции возвращают новый поток, который можно использовать для дальнейших операций. Примеры промежуточных
операций:

filter(): фильтрует элементы потока на основе заданного условия
map(): преобразует каждый элемент потока в другой объект
flatMap(): преобразует каждый элемент потока в поток объектов и объединяет все потоки в один
sorted(): сортирует элементы потока
Конечные операции возвращают результат или выполняют действие с потоком. Примеры конечных операций:

forEach(): выполняет действие для каждого элемента потока
collect(): собирает элементы потока в коллекцию
reduce(): сводит элементы потока в одно значение
Теперь, чем map() отличается от flatMap()?

map() преобразует каждый элемент потока в другой объект, возвращая поток объектов того же типа.

flatMap() преобразует каждый элемент потока в поток объектов и объединяет все потоки в один. Это означает, что если у
вас есть поток, содержащий коллекции, flatMap() может преобразовать его в поток отдельных элементов.

### 3. Spring Framework

#### 3.1 Что такое Spring Framework? Для чего он нужен?

Ожидаемый ответ:

Spring Framework предназначен для упрощения разработки enterprise-приложений, предоставляя набор инструментов и
технологий для решения различных задач, таких как:

Dependency Injection (DI): управление зависимостями между компонентами приложения
Aspect-Oriented Programming (AOP): разделение аспектов приложения, таких как безопасность, логирование и транзакции
Data Access: работа с базами данных и другими источниками данных
Web Development: создание веб-приложений с использованием различных технологий, таких как Servlet, JSP и Spring MVC
Security: обеспечение безопасности приложения с помощью аутентификации и авторизации
Testing: тестирование приложения с помощью различных инструментов и технологий

#### 3.2 Что такое IoC-контейнер в Spring Framework?

Ожидаемый ответ:

IoC-контейнер (Inversion of Control container) в Spring Framework - это центральный компонент, который управляет
созданием и конфигурацией объектов приложения. Он является основой для Dependency Injection (DI) и позволяет упростить
разработку приложений, делая их более гибкими и масштабируемыми.

IoC-контейнер в Spring Framework отвечает за следующие задачи:

Создание объектов: контейнер создает объекты приложения на основе конфигурации, заданной в XML-файлах, аннотациях или
Java-коде.
Управление зависимостями: контейнер управляет зависимостями между объектами, обеспечивая их правильную инициализацию и
конфигурацию.
Управление жизненным циклом: контейнер управляет жизненным циклом объектов, включая их создание, инициализацию,
использование и уничтожение.
Предоставление сервисов: контейнер предоставляет сервисы, такие как аутентификация, авторизация, транзакции и
логирование, которые могут быть использованы объектами приложения.

В Spring Framework есть два типа IoC-контейнеров:

BeanFactory: это базовый IoC-контейнер, который предоставляет основные функции для управления объектами.
ApplicationContext: это расширенный IoC-контейнер, который предоставляет дополнительные функции, такие как поддержку
аутентификации, авторизации и транзакций.

#### 3.2 Назови все скоупы бинов

Ожидаемый ответ:

1. Singleton (Синглтон) - бин создается только один раз и используется во всем приложении.
2. Prototype (Прототип) - бин создается каждый раз, когда он запрашивается.
3. Request (Запрос) - бин создается для каждого HTTP-запроса и уничтожается после окончания запроса.
4. Session (Сессия) - бин создается для каждой HTTP-сессии и уничтожается после окончания сессии.
5. Application (Приложение) - бин создается для всего приложения и уничтожается после окончания работы приложения.
6. WebSocket (WebSocket) - бин создается для каждого WebSocket-соединения и уничтожается после окончания соединения.

#### 3.2.1 Что будет если в Singleton bean заинжектить Prototype bean?

Ожидаемый ответ:

В Spring Framework, Singleton-бин - это бин, который создается только один раз и используется во всем приложении.
Прототип-бин, с другой стороны, это бин, который создается каждый раз, когда он запрашивается.

Когда Singleton-бин зависит от Прототип-бина, возникает интересная ситуация. Поскольку Singleton-бин создается только
один раз, он получит только один экземпляр Прототип-бина, который будет использоваться во всем приложении. Однако
Прототип-бин создается каждый раз, когда он запрашивается, поэтому Singleton-бин будет использовать только первый
созданный экземпляр Прототип-бина.

Это может привести к проблемам, если Прототип-бин имеет состояние, которое меняется в зависимости от использования. В
этом случае Singleton-бин будет использовать устаревшее состояние Прототип-бина, что может привести к ошибкам.

#### 3.2.2 Что такое циклические зависимости и как их разрешить?

Ожидаемый ответ:

Циклические зависимости - это ситуации, когда два или более бинов зависят друг от друга, образуя замкнутый цикл. Это
может привести к проблемам при создании и конфигурации бинов, поскольку Spring Framework не может определить, какой бин
создать первым.

1. Удалить циклическую зависимость: если циклическая зависимость не необходима, можно удалить ее, перестроив код так,
   чтобы бины не зависели друг от друга.
2. Использовать ленивую инициализацию: можно использовать ленивую инициализацию, чтобы создать бин только тогда, когда
   он
3. действительно необходим. Это можно сделать с помощью аннотации @Lazy.
4. Использовать сеттеры.
5. Использовать @PostConstruct

### 4. Hibernate

#### 4.1 Что такое ORM?

#### 4.2 Как работает кеш в Hibernate?

Ожидаемый ответ:

Кеш в Hibernate - это механизм, который позволяет хранить результаты запросов к базе данных в памяти, чтобы избежать
повторных запросов к базе данных и уменьшить время ответа приложения.

Hibernate предоставляет два типа кеша:

Первый уровень кеша (L1): это кеш, который хранит результаты запросов к базе данных в памяти JVM (Java Virtual Machine).
L1 кеш используется для хранения результатов запросов, которые были выполнены ранее, и которые могут быть повторно
использованы.
Второй уровень кеша (L2): это кеш, который хранит результаты запросов к базе данных в отдельном хранилище, которое может
быть расположено на другом сервере или в кластере серверов. L2 кеш используется для хранения результатов запросов,
которые могут быть повторно использованы между разными JVM.
Работа кеша в Hibernate происходит следующим образом:

Запрос к базе данных: приложение отправляет запрос к базе данных через Hibernate.
Проверка L1 кеша: Hibernate проверяет, есть ли результаты запроса в L1 кеше. Если результаты есть, Hibernate возвращает
их из кеша.
Проверка L2 кеша: если результаты запроса нет в L1 кеше, Hibernate проверяет, есть ли они в L2 кеше. Если результаты
есть, Hibernate возвращает их из L2 кеша.
Выполнение запроса: если результаты запроса нет в L1 и L2 кешах, Hibernate выполняет запрос к базе данных.
Хранение результатов в кеше: после выполнения запроса, Hibernate хранит результаты в L1 кеше и, если необходимо, в L2
кеше.
Hibernate предоставляет несколько стратегий кеширования, которые можно использовать для управления кешем:

CacheConcurrencyStrategy: определяет стратегию кеширования, которая используется для управления кешем.
CacheProvider: определяет провайдер кеша, который используется для хранения результатов запросов.
CacheRegion: определяет регион кеша, который используется для хранения результатов запросов.
Некоторые из наиболее распространенных стратегий кеширования в Hibernate включают:

READ_ONLY: кеш используется только для чтения, и результаты запросов не обновляются.
READ_WRITE: кеш используется для чтения и записи, и результаты запросов обновляются.
NONSTRICT_READ_WRITE: кеш используется для чтения и записи, но результаты запросов не обновляются, если они не были
изменены.
В целом, кеш в Hibernate может существенно улучшить производительность приложения, уменьшив время ответа и количество
запросов к базе данных.

#### 4.3 Что такое проблема N+1 и как ее решить в Hibernate?

Ожидаемый ответ:

Проблема N+1 - это распространенная проблема в Hibernate, которая возникает, когда приложение выполняет множество
запросов к базе данных для получения связанных данных.

1. Join fetching: вместо того, чтобы выполнять отдельные запросы для получения связанных данных, можно использовать join
   fetching для получения всех данных в одном запросе.
2. Batch fetching: можно использовать batch fetching для получения связанных данных в пакетах, что может уменьшить
   количество запросов к базе данных.
3. Lazy loading: можно использовать lazy loading для отложенной загрузки связанных данных, что может уменьшить
   количество запросов к базе данных.
4. Fetch profiles: можно использовать fetch profiles для определения того, какие данные должны быть загружены вместе с
   основными данными.
5. Query optimization: можно использовать query optimization для оптимизации запросов и уменьшения количества запросов к
   базе данных.
6. EntityGraph

### 5. Базы данных

#### 5.1 Что такое реляционная БД?

Ожидаемый ответ:

Реляционная база данных (РБД) - это тип базы данных, которая хранит данные в виде таблиц, связанных между собой через
отношения.

В РБД данные представлены в виде таблиц, каждая из которых имеет ряды (записи) и столбцы (атрибуты). Каждая запись в
таблице представляет собой отдельный набор данных, а каждый атрибут представляет собой отдельное поле данных.

Отношения между таблицами в РБД определяются с помощью ключей. Ключ - это уникальный идентификатор записи в таблице,
который позволяет связать ее с записями в других таблицах.

Реляционные базы данных поддерживают следующие типы отношений:

* Один к одному (1:1): одна запись в одной таблице соответствует одной записи в другой таблице.
* Один ко многим (1:N): одна запись в одной таблице соответствует нескольким записям в другой таблице.
* Многие ко многим (M:N): несколько записей в одной таблице соответствуют нескольким записям в другой таблице.
  Реляционные базы данных обеспечивают следующие преимущества:

Упорядоченность данных: данные хранятся в виде таблиц, что позволяет легко управлять ими и поддерживать их актуальность.
Уникальность данных: каждая запись в таблице имеет уникальный идентификатор, что позволяет избежать дублирования данных.
Связность данных: отношения между таблицами позволяют связать данные из разных таблиц и обеспечивают целостность данных.
Масштабируемость: реляционные базы данных могут хранить большие объемы данных и обеспечивать высокую производительность.

Однако реляционные базы данных также имеют некоторые ограничения, такие как:

* Сложность структуры данных
* Ограниченная гибкость
* Требование к нормализации данных

#### 5.2 Что такое индексы в РБД? Для чего их используют? В чем их преимущества и недостатки?

Ожидаемый ответ:

Индекс (index) — объект базы данных, создаваемый с целью повышения производительности выборки данных.

Наборы данных могут иметь большое количество записей, которые хранятся в произвольном порядке, и их поиск по заданному
критерию путём последовательного просмотра набора данных запись за записью может занимать много времени. Индекс
формируется из значений одного или нескольких полей и указателей на соответствующие записи набора данных, - таким
образом, достигается значительный прирост скорости выборки из этих данных.

Преимущества

* ускорение поиска и сортировки по определенному полю или набору полей.
* обеспечение уникальности данных.

Недостатки

* требование дополнительного места на диске и в оперативной памяти и чем больше/длиннее ключ, тем больше размер индекса.
* замедление операций вставки, обновления и удаления записей, поскольку при этом приходится обновлять сами индексы.

Индексы предпочтительней для:

* Поля-счетчика, чтобы, в том числе избежать и повторения значений в этом поле;
* Поля, по которому проводится сортировка данных;
* Полей, по которым часто проводится соединение наборов данных. Поскольку в этом случае данные располагаются в порядке
  возрастания индекса и соединение происходит значительно быстрее;
* Поля, которое объявлено первичным ключом (primary key);
* Поля, в котором данные выбираются из некоторого диапазона. В этом случае как только будет найдена первая запись с
  нужным значением, все последующие значения будут расположены рядом.

Использование индексов нецелесообразно для:

* Полей, которые редко используются в запросах;
* Полей, которые содержат всего два или три значения, например: мужской, женский пол или значения «да», «нет». (
  Примерное правило, которым можно руководствоваться при создании индекса - если объем информации (в байтах) НЕ
  удовлетворяющей условию выборки меньше, чем размер индекса (в байтах) по данному условию выборки, то в общем случае
  оптимизация приведет к замедлению выборки.)

#### 5.3 Какие типы индексов бывают по структуре?

Ожидаемый ответ:

* B*-деревья;
* B+-деревья;
* B-деревья;
* Хэши.

#### 5.4 Нужно ли создавать индекс для первичного ключа?

Ожидаемый ответ:

Нет, для первичного ключа индекс создается автоматически.

#### 5.5 Что такое ACID?

Ожидаемый ответ:

ACID (Atomicity, Consistency, Isolation, Durability) - это набор свойств, которые должны быть обеспечены базой данных
для поддержания целостности и надежности данных.

ACID представляет собой набор правил, которые определяют, как база данных должна обрабатывать транзакции, чтобы
обеспечить целостность и надежность данных.

**Атомарность (Atomicity):**

* Транзакция должна быть обработана как единое целое, т.е. либо все изменения должны быть применены, либо ни одно
  изменение не должно быть применено.
* Если транзакция не может быть завершена, все изменения должны быть отменены.

**Согласованность (Consistency):**

* Транзакция должна оставить базу данных в согласованном состоянии, т.е. все данные должны быть корректными и
  соответствовать бизнес-правилам.
* Транзакция не должна нарушать целостность данных.

**Изоляция (Isolation):**

* Транзакция должна быть обработана независимо от других транзакций, т.е. изменения, внесенные одной транзакцией, не
  должны быть видны другой транзакции до тех пор, пока первая транзакция не будет завершена.
* Транзакция должна быть защищена от влияния других транзакций.

**Надежность (Durability):**

* После завершения транзакции все изменения должны быть сохранены и должны быть доступны для чтения и записи.
* Транзакция должна быть защищена от потери данных в случае сбоя или аварии.

ACID обеспечивает следующие преимущества:

Целостность данных: ACID гарантирует, что данные будут корректными и согласованными.
Надежность: ACID гарантирует, что транзакции будут обработаны правильно и что данные будут сохранены.
Безопасность: ACID гарантирует, что данные будут защищены от несанкционированного доступа и изменения.

#### 5.6 Что такое транзакция?

Ожидаемый ответ:

Транзакция - это воздействие на базу данных, переводящее её из одного целостного состояния в другое и выражаемое в
изменении данных, хранящихся в базе данных.

#### 5.7 Какие уровни изоляции транзакций существуют?

Ожидаемый ответ:

В базах данных существуют четыре уровня изоляции транзакций:

* **Чтение неподтвержденных данных (Read Uncommitted)**: Этот уровень изоляции позволяет транзакциям читать данные,
  которые
  еще не были подтверждены другими транзакциями. Это означает, что транзакция может прочитать данные, которые могут быть
  отменены или изменены другой транзакцией.
* **Чтение подтвержденных данных (Read Committed)**: Этот уровень изоляции гарантирует, что транзакция будет читать
  только
  подтвержденные данные. Это означает, что транзакция не будет читать данные, которые еще не были подтверждены другими
  транзакциями.
* **Повторяемое чтение (Repeatable Read)**: Этот уровень изоляции гарантирует, что транзакция будет читать данные,
  которые
  были подтверждены на момент начала транзакции. Это означает, что транзакция будет читать данные, которые были
  подтверждены на момент начала транзакции, и не будет читать данные, которые были изменены или добавлены другими
  транзакциями после начала транзакции.
* **Сериализуемое чтение (Serializable)**: Этот уровень изоляции гарантирует, что транзакция будет читать данные,
  которые
  были подтверждены на момент начала транзакции, и что транзакция будет выполняться в порядке, который гарантирует
  отсутствие
  конфликтов с другими транзакциями. Это означает, что транзакция будет читать данные, которые были подтверждены на
  момент начала транзакции, и что транзакция будет выполняться в порядке, который гарантирует отсутствие конфликтов с
  другими
  транзакциями.

#### 5.8 Какие проблемы могут возникать при параллельном доступе с использованием транзакций?

Ожидаемый ответ:

При параллельном выполнении транзакций возможны следующие проблемы:

* **Потерянное обновление (lost update)** — при одновременном изменении одного блока данных разными транзакциями одно из
  изменений теряется;
* **«Грязное» чтение (dirty read)** — чтение данных, добавленных или изменённых транзакцией, которая впоследствии не
  подтвердится (откатится);
* **Неповторяющееся чтение (non-repeatable read)** — при повторном чтении в рамках одной транзакции ранее прочитанные
  данные
  оказываются изменёнными;
* **Фантомное чтение (phantom reads)** — одна транзакция в ходе своего выполнения несколько раз выбирает множество
  записей по
  одним и тем же критериям. Другая транзакция в интервалах между этими выборками добавляет или удаляет записи, или
  изменяет
  столбцы некоторых записей, используемых в критериях выборки первой транзакции, и успешно заканчивается. В результате
  получится, что одни и те же выборки в первой транзакции дают разные множества записей.

### 6. WEB

#### 6.1 Что такое TCP/IP?

Ожидаемый ответ:

TCP/IP - это два основных сетевых протокола Internet. Часто это название используют и для обозначения сетей, работающих
на их основе.

IP (Internet Protocol) - маршрутизируемый протокол, отвечающий за IP-адресацию, маршрутизацию, фрагментацию и
восстановление пакетов. В его задачу входит продвижение пакета между сетями – от одного маршрутизатора до другого и тех
пор, пока пакет не попадет в сеть назначения. В отличие от протоколов прикладного и транспортного уровней, протокол IP
разворачивается не только на хостах, но и на всех шлюзах (маршрутизаторах). Этот протокол работает без установления
соединения и без гарантированной доставки.

TCP (Transfer Control Protocol) - протокол, обеспечивающий надежную, требующую логического соединения связь между двумя
компьютерами. Отвечает за установление соединения, упорядочивание посылаемых пакетов и восстановление пакетов,
потерянных в процессе передачи.

#### 6.2 Что такое UDP?

Ожидаемый ответ:

UDP, User Datagram Protocol (Протокол пользовательских датаграмм) — протокол, который обеспечивает доставку без требований соединения с удаленным модулем UDP и обязательного подтверждения получения.

К заголовку IP-пакета UDP добавляет всего четыре поля по 2 байта каждое:

* поле порта источника (source port)
* поле порта пункта назначения (destination port)
* поле длины (length)
* поле контрольной суммы (checksum)
Поля «порт источника» и «контрольная сумма» не являются обязательными для использования в IPv4. В IPv6 необязательно только поле «порт отправителя».

UDP используется DNS, SNMP, DHCP и другими приложениями.

#### 6.3 Чем отличаются UDP и TCP?

Ожидаемый ответ:

**TCP** — ориентированный на соединение протокол, что означает необходимость «рукопожатия» для установки соединения между двумя хостами. Как только соединение установлено, пользователи могут отправлять данные в обоих направлениях.

* Надёжность — TCP управляет подтверждением, повторной передачей и тайм-аутом сообщений. Производятся многочисленные попытки доставить сообщение. Если оно потеряется на пути, сервер вновь запросит потерянную часть. В TCP нет ни пропавших данных, ни (в случае многочисленных тайм-аутов) разорванных соединений.
* Упорядоченность — если два сообщения последовательно отправлены, первое сообщение достигнет приложения-получателя первым. Если участки данных приходят в неверном порядке, TCP отправляет неупорядоченные данные в буфер до тех пор, пока все данные не могут быть упорядочены и переданы приложению.
* Тяжеловесность — TCP необходимо три пакета для установки соединения перед тем, как отправить данные. TCP следит за надёжностью и перегрузками.
* Потоковость — данные читаются как поток байтов, не передается никаких особых обозначений для границ сообщения или сегментов.

**UDP** — более простой, основанный на сообщениях протокол без установления соединения. Протоколы такого типа не устанавливают выделенного соединения между двумя хостами. Связь достигается путём передачи информации в одном направлении от источника к получателю без проверки готовности или состояния получателя.

* Ненадёжность — когда сообщение посылается, неизвестно, достигнет ли оно своего назначения — оно может потеряться по пути. Нет таких понятий как подтверждение, повторная передача, тайм-аут.
* Неупорядоченность — если два сообщения отправлены одному получателю, то порядок их достижения цели не может быть предугадан.
* Легковесность — никакого упорядочивания сообщений, никакого отслеживания соединений и т. д. Это лишь транспортный уровень.
* Датаграммы — пакеты посылаются по отдельности и проверяются на целостность только если они прибыли. Пакеты имеют определенные границы, которые соблюдаются после получения, то есть операция чтения на получателе выдаст сообщение таким, каким оно было изначально послано.
* Отсутствие контроля перегрузок — для приложений с большой пропускной способностью существует шанс вызвать коллапс перегрузок, если только они не реализуют меры контроля на прикладном уровне.

#### 6.4 Что такое HTTP/HTTPS?

Ожидаемый ответ:

HTTP, HyperText Transfer Protocol (Протокол передачи гипертекста) — протокол прикладного уровня передачи данных.

Основой HTTP является технология «клиент-сервер»:

* Потребители (клиенты), которые инициируют соединение и посылают запрос;
* Поставщики (серверы), которые ожидают соединения для получения запроса, производят необходимые действия и возвращают обратно сообщение с результатом.

Для идентификации ресурсов HTTP использует глобальные URI.

HTTP не сохраняет своего состояния. Это означает отсутствие сохранения промежуточного состояния между парами «запрос-ответ».

Структура протокола:

* Стартовая строка (starting line) — определяет тип сообщения;
* Заголовки (headers) — характеризуют тело сообщения, параметры передачи и прочие сведения;
* Тело сообщения (message body) — непосредственно данные сообщения. Обязательно должно отделяться от заголовков пустой строкой.

Заголовки и тело сообщения могут отсутствовать, но стартовая строка является обязательным элементом, так как указывает на тип запроса/ответа.

HTTPS, HyperText Transfer Protocol Secure — расширение протокола HTTP, поддерживающее шифрование. Данные, передаваемые по протоколу HTTPS, «упаковываются» в криптографический протокол SSL или TLS, что обеспечивает защиту от атак, основанных на прослушивании сетевого соединения (при условии, что будут использоваться шифрующие средства и сертификат сервера проверен и ему доверяют).

Различия HTTP и HTTPS:

HTTPS является расширением HTTP.

HTTP использует не зашифрованное соединение. Соединение по HTTPS поддерживает шифрование.

Работа по HTTP быстрей и менее ресурсоёмкая, т.к. шифрование HTTPS требует дополнительных затрат.

Порты по умолчанию: в случае HTTP это TCP-порт 80, для HTTPS - TCP-порт 443.

#### 6.5 Что происходит когда вводишь URL в браузере?

Ожидаемый ответ:

Когда вы вводите URL в браузере, происходит следующий процесс:

* Парсинг URL: Браузер разбирает введенный URL на его компоненты, такие как протокол (http или https), домен, путь и параметры.
* Резолвинг домена: Браузер отправляет запрос на сервер имен (DNS) для получения IP-адреса домена. DNS-сервер возвращает IP-адрес, который соответствует домену.
* Установление соединения: Браузер устанавливает соединение с сервером по протоколу TCP/IP, используя полученный IP-адрес.
* Отправка запроса: Браузер отправляет HTTP-запрос на сервер, который включает в себя метод запроса (GET, POST, PUT, DELETE и т. д.), заголовки и тело запроса.
* Обработка запроса на сервере: Сервер получает запрос и обрабатывает его, используя соответствующий обработчик запросов. Обработчик запросов может быть написан на любом языке программирования, таком как PHP, Python, Ruby и т. д.
* Возвращение ответа: Сервер возвращает HTTP-ответ, который включает в себя статусный код, заголовки и тело ответа.
* Получение ответа: Браузер получает ответ и обрабатывает его, используя соответствующий обработчик ответов.
* Отображение содержимого: Браузер отображает содержимое ответа, которое может быть HTML-страницей, изображением, файлом и т. д.

* Весь этот процесс происходит очень быстро, обычно за несколько секунд. Однако, если сервер находится далеко или имеет высокую нагрузку, время ответа может быть больше.

Кроме того, современные браузеры также используют различные оптимизации, такие как:

* Кеширование: Браузер хранит часто используемые ресурсы, такие как изображения и скрипты, в кеше, чтобы избежать повторных запросов на сервер.
* Сжатие: Браузер сжимает данные, отправляемые на сервер, чтобы уменьшить объем передаваемых данных.
* Параллельные запросы: Браузер отправляет несколько запросов на сервер одновременно, чтобы уменьшить время ожидания.

Эти оптимизации помогают ускорить процесс загрузки страниц и сделать интернет-браузинг более быстрым и эффективным.


### 7. Микросервисы

#### 7.1 Что такое микросервисы?

Ожидаемый ответ:

Микросервисы - это архитектурный подход к разработке программного обеспечения, в котором приложение разбивается на
небольшие и независимые сервисы, каждый из которых выполняет конкретную функцию. Каждый микросервис может быть
разработан, развернут и масштабирован независимо от других сервисов в приложении.

#### 7.2 Плюсы и минусы

Ожидаемый ответ:

Микросервисная архитектура имеет несколько преимуществ и недостатков. Вот некоторые из них:

Преимущества микросервисной архитектуры:

* Гибкость и масштабируемость: Микросервисы могут быть разработаны и развернуты независимо друг от друга, что позволяет
  гибко масштабировать систему в зависимости от потребностей. Это также упрощает добавление новых функций и изменение
  существующих без влияния на другие сервисы.
* Легкость в сопровождении: Каждый микросервис отвечает только за определенную функциональность, что упрощает понимание
  и
  сопровождение кода. Команды разработчиков могут работать над разными сервисами независимо друг от друга, что повышает
  производительность.
* Устойчивость к сбоям: Если один микросервис выходит из строя, это не приводит к полному отказу системы. Остальные
  сервисы продолжают работу, что обеспечивает более высокую доступность и надежность системы.
* Использование разных технологий: Разные микросервисы могут быть разработаны с использованием разных технологий и
  языков
  программирования в зависимости от их специфических требований. Это позволяет выбирать наиболее подходящие инструменты
  для каждого сервиса.

Недостатки микросервисной архитектуры:

* Сложность управления: Управление микросервисной архитектурой может быть сложным из-за необходимости отслеживать и
  контролировать множество сервисов. Это может потребовать дополнительных усилий для мониторинга, отладки и обновления
  каждого сервиса.
* Сетевая сложность: Взаимодействие между микросервисами происходит через сеть, что может привести к задержкам и потере
  производительности. Необходимость обеспечения надежности и безопасности сетевого взаимодействия также может быть
  вызовом.
* Увеличенные затраты на инфраструктуру: Каждый микросервис требует собственной инфраструктуры и ресурсов, что может
  повлечь дополнительные затраты на оборудование и поддержку.
* Сложность тестирования: Тестирование микросервисной архитектуры может быть сложным из-за необходимости проверять
  взаимодействие между разными сервисами. Это требует более сложной инфраструктуры тестирования и стратегии
  тестирования.

Несмотря на некоторые недостатки, микросервисная архитектура становится все более популярной из-за своей гибкости и
масштабируемости. Решение о ее применении должно быть основано на конкретных потребностях и ограничениях проекта.

#### 7.3 Монолит

Ожидаемый ответ:

Монолитная архитектура представляет собой подход, при котором вся функциональность приложения находится в одном целом -
монолите. В монолитной архитектуре все компоненты приложения взаимодействуют непосредственно друг с другом. Все эти
компоненты разворачиваются вместе и масштабируются вместе. Обновления и изменения в монолите требуют пересборки всего
приложения.

Основное отличие между монолитной и микросервисной архитектурами заключается в масштабируемости и гибкости. Монолитная
архитектура проста в разработке и развертывании, но может стать сложной для масштабирования и поддержки в случае больших
и сложных приложений.

#### 7.4 Синхронное и асинхронное взаимодействие между микросервисами

Ожидаемый ответ:

Синхронное и асинхронное взаимодействие между микросервисами - это два различных подхода к обмену данными между сервисами в микросервисной архитектуре.

Синхронное взаимодействие

Синхронное взаимодействие между микросервисами означает, что один сервис отправляет запрос другому сервису и ожидает ответа перед тем, как продолжить свою работу. Это означает, что сервис, отправивший запрос, блокируется до тех пор, пока не получит ответ от другого сервиса.

Пример синхронного взаимодействия:

Сервис A отправляет запрос сервису B на получение данных.
Сервис B обрабатывает запрос и отправляет ответ сервису A.
Сервис A получает ответ и продолжает свою работу.

Преимущества синхронного взаимодействия:

* Легко реализовать и понять.
* Обеспечивает сильную связь между сервисами.
* Позволяет использовать стандартные протоколы, такие как HTTP.

* Недостатки синхронного взаимодействия:

* Может привести к блокировке сервисов, если один из сервисов не отвечает.
* Не подходит для высоконагруженных систем, где необходимо обрабатывать много запросов одновременно.

Асинхронное взаимодействие

Асинхронное взаимодействие между микросервисами означает, что один сервис отправляет запрос другому сервису, но не ожидает ответа. Вместо этого, сервис, отправивший запрос, продолжает свою работу, а ответ от другого сервиса обрабатывается отдельно.

Пример асинхронного взаимодействия:

Сервис A отправляет запрос сервису B на получение данных.
Сервис A продолжает свою работу, не ожидая ответа.
Сервис B обрабатывает запрос и отправляет ответ сервису A.
Сервис A получает ответ и обрабатывает его отдельно.

Преимущества асинхронного взаимодействия:

* Позволяет избежать блокировки сервисов.
* Подходит для высоконагруженных систем, где необходимо обрабатывать много запросов одновременно.
* Обеспечивает слабую связь между сервисами.

Недостатки асинхронного взаимодействия:

* Более сложно реализовать и понять.
* Требует использования специальных протоколов, таких как AMQP или Kafka.
* В общем, синхронное взаимодействие подходит для систем, где необходимо обеспечить сильную связь между сервисами, а асинхронное взаимодействие подходит для систем, где необходимо обеспечить высокую производительность и слабую связь между сервисами.

#### 7.5 Что такое брокер сообщений?

Ожидаемый ответ:

Брокер сообщений в микросервисной архитектуре - это компонент, который помогает в обмене сообщениями между
микросервисами. Брокер сообщений позволяет микросервисам отправлять и получать сообщения асинхронно, без необходимости
прямого взаимодействия между собой.

Брокер сообщений обеспечивает следующие функции:

* Хранение сообщений: Брокер сообщений хранит сообщения, которые были отправлены микросервисами, до тех пор, пока они не
будут получены другими микросервисами.
* Распределение сообщений: Брокер сообщений распределяет сообщения между микросервисами, основываясь на определенных
правилах или политиках.
* Обеспечение надежности: Брокер сообщений обеспечивает надежность обмена сообщениями, т.е. гарантирует, что сообщение
будет доставлено получателю, даже если один из сервисов упадет или будет недоступен.
* Обработка ошибок: Брокер сообщений обрабатывает ошибки доставки сообщений и позволяет микросервисам повторно отправлять
сообщения, если они не были доставлены успешно.

Брокер сообщений может быть реализован на основе различных протоколов, таких как:

AMQP (Advanced Message Queuing Protocol)
Kafka
RabbitMQ
Apache Pulsar

Преимущества использования брокера сообщений в микросервисной архитектуре:

* Позволяет микросервисам обмениваться данными асинхронно, без необходимости прямого взаимодействия.
* Обеспечивает надежность обмена сообщениями и повторную отправку сообщений, если они не были доставлены успешно.
* Позволяет микросервисам обрабатывать сообщения независимо от других микросервисов.
* Обеспечивает масштабируемость и высокую производительность обмена сообщениями.

В общем, брокер сообщений помогает обеспечить надежность и масштабируемость обмена сообщениями между микросервисами в
микросервисной архитектуре.

#### 7.6 Что такое REST/RESTful?

Ожидаемый ответ:

REST (Representational State Transfer) - это архитектурный стиль, который используется для разработки распределенных
систем. RESTful - это подход к проектированию веб-сервисов, который следует принципам REST.

Основная цель REST / RESTful состоит в том, чтобы создать веб-сервисы, которые могут быть легко масштабируемы, надежными
и расширяемыми. Он стремится к созданию простых, легко понятных и удобных для использования интерфейсов, которые могут
быть использованы различными клиентами.

RESTful веб-сервисы основаны на протоколе HTTP и используют его методы (GET, POST, PUT, DELETE) для взаимодействия с
ресурсами. Они также используют уникальные идентификаторы ресурсов (URL) для доступа к ним.

RESTful веб-сервисы обычно возвращают данные в формате JSON или XML, что делает их легко читаемыми и понятными для
клиентов.

Основные принципы REST / RESTful:

* Client-Server (Клиент-Сервер): Взаимодействие между клиентом и сервером осуществляется через стандартизированный
интерфейс.
* Stateless (Без сохранения состояния): Каждый запрос от клиента к серверу должен содержать всю необходимую информацию для
его обработки. Сервер не должен сохранять состояние между запросами.
* Cacheable (Кэшируемость): Ответы сервера могут быть кэшированы на стороне клиента для повторного использования.
* Uniform Interface (Единый интерфейс): Интерфейс взаимодействия должен быть однородным и простым для понимания.
* Layered System (Слоистая система): Серверы могут быть разделены на слои, чтобы обеспечить масштабируемость и
безопасность.

Пример использования RESTful веб-сервиса: Предположим, у нас есть веб-приложение для управления задачами. Мы можем
использовать RESTful веб-сервисы для создания, чтения, обновления и удаления задач.

Чтение задачи: GET /tasks/{id}
Создание задачи: POST /tasks
Обновление задачи: PUT /tasks/{id}
Удаление задачи: DELETE /tasks/{id}

RESTful веб-сервисы обеспечивают простоту и гибкость взаимодействия между клиентом и сервером, что делает их популярным
выбором для разработки распределенных систем.

#### 7.7 Что такое SOAP?

Ожидаемый ответ:

SOAP (Simple Object Access Protocol) - это протокол обмена данными между приложениями, который позволяет отправлять и
получать сообщения в формате XML (Extensible Markup Language) через Интернет.

Плюсы SOAP:

* Стандартизация: SOAP является стандартным протоколом, который поддерживается большинством платформ и языков
  программирования.
* Безопасность: SOAP позволяет использовать различные механизмы безопасности, такие как шифрование и аутентификацию, для
  защиты данных.
* Надежность: SOAP обеспечивает надежную доставку сообщений, поскольку он использует подтверждение доставки и повторную
  отправку сообщений.
* Масштабируемость: SOAP позволяет легко масштабировать приложения, поскольку он поддерживает большое количество
  сообщений и пользователей.
* Поддержка различных форматов данных: SOAP позволяет отправлять и получать данные в различных форматах, таких как XML,
  JSON и другие.

Минусы SOAP:

* Сложность: SOAP является сложным протоколом, который требует значительных знаний и опыта для его реализации.
* Медленная скорость: SOAP является медленным протоколом, поскольку он использует XML для передачи данных, что может
  привести к увеличению времени передачи данных.
* Большой размер сообщений: SOAP сообщения могут быть большими, поскольку они содержат много метаданных, что может
  привести к увеличению времени передачи данных.
* Необходимость использования специальных библиотек: SOAP требует использования специальных библиотек и инструментов для
  его реализации, что может быть неудобно для некоторых разработчиков.
* Низкая производительность: SOAP может иметь низкую производительность, поскольку он использует много ресурсов для
  обработки сообщений.

## Лайф-кодинг

### Первая задача

Есть список слов, мы хотим вывести число включений каждой буквы

`List<String> items = Arrays.asList("Илья", "Антон", "Никита");`

Ожидаемый ответ:

`Map<Character, Long> letterCounts = items.stream()
.flatMap(s -> s.chars().mapToObj(c -> (char) c))
.collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));
letterCounts.forEach((letter, count) -> System.out.println(letter + ": " + count));`

### Вторая задача

Необходимо провести code-review

https://codeshare.io/WLmkoM
